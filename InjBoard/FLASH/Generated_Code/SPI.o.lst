   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"SPI.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	28
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.SPI_Init,"ax",%progbits
  24              		.align	2
  25              		.global	SPI_Init
  26              		.code	16
  27              		.thumb_func
  29              	SPI_Init:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/SPI.c"
   1:../Generated_Code/SPI.c **** /* ###################################################################
   2:../Generated_Code/SPI.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/SPI.c **** **     Filename    : SPI.c
   4:../Generated_Code/SPI.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/SPI.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/SPI.c **** **     Component   : SPIMaster_LDD
   7:../Generated_Code/SPI.c **** **     Version     : Component 01.111, Driver 01.02, CPU db: 3.00.000
   8:../Generated_Code/SPI.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/SPI.c **** **     Date/Time   : 2017-02-10, 23:17, # CodeGen: 22
  10:../Generated_Code/SPI.c **** **     Abstract    :
  11:../Generated_Code/SPI.c **** **         This component "SPIMaster_LDD" implements MASTER part of synchronous
  12:../Generated_Code/SPI.c **** **         serial master-slave communication.
  13:../Generated_Code/SPI.c **** **     Settings    :
  14:../Generated_Code/SPI.c **** **          Component name                                 : SPI
  15:../Generated_Code/SPI.c **** **          Device                                         : SPI0
  16:../Generated_Code/SPI.c **** **          Interrupt service/event                        : Disabled
  17:../Generated_Code/SPI.c **** **          Settings                                       : 
  18:../Generated_Code/SPI.c **** **            Input pin                                    : Enabled
  19:../Generated_Code/SPI.c **** **              Pin                                        : PTD2/SPI0_MOSI/UART2_RX/TPM0_CH2/SPI0_
  20:../Generated_Code/SPI.c **** **              Pin signal                                 : 
  21:../Generated_Code/SPI.c **** **            Output pin                                   : Enabled
  22:../Generated_Code/SPI.c **** **              Pin                                        : PTD3/SPI0_MISO/UART2_TX/TPM0_CH3/SPI0_
  23:../Generated_Code/SPI.c **** **              Pin signal                                 : 
  24:../Generated_Code/SPI.c **** **            Clock pin                                    : 
  25:../Generated_Code/SPI.c **** **              Pin                                        : ADC0_SE5b/PTD1/SPI0_SCK/TPM0_CH1
  26:../Generated_Code/SPI.c **** **              Pin signal                                 : 
  27:../Generated_Code/SPI.c **** **            Chip select list                             : 0
  28:../Generated_Code/SPI.c **** **            Attribute set list                           : 1
  29:../Generated_Code/SPI.c **** **              Attribute set 0                            : 
  30:../Generated_Code/SPI.c **** **                Width                                    : 8 bits
  31:../Generated_Code/SPI.c **** **                MSB first                                : yes
  32:../Generated_Code/SPI.c **** **                Clock polarity                           : Low
  33:../Generated_Code/SPI.c **** **                Clock phase                              : Capture on leading edge
  34:../Generated_Code/SPI.c **** **                Parity                                   : None
  35:../Generated_Code/SPI.c **** **                Chip select toggling                     : yes
  36:../Generated_Code/SPI.c **** **                Clock rate index                         : 0
  37:../Generated_Code/SPI.c **** **            Clock rate                                   : 1 µs
  38:../Generated_Code/SPI.c **** **            HW input buffer size                         : Max buffer size
  39:../Generated_Code/SPI.c **** **            HW input watermark                           : 1
  40:../Generated_Code/SPI.c **** **            Receiver DMA                                 : Disabled
  41:../Generated_Code/SPI.c **** **            HW output buffer size                        : Max buffer size
  42:../Generated_Code/SPI.c **** **            HW output watermark                          : 1
  43:../Generated_Code/SPI.c **** **            Transmitter DMA                              : Disabled
  44:../Generated_Code/SPI.c **** **          Initialization                                 : 
  45:../Generated_Code/SPI.c **** **            Initial chip select                          : 0
  46:../Generated_Code/SPI.c **** **            Initial attribute set                        : 0
  47:../Generated_Code/SPI.c **** **            Enabled in init. code                        : yes
  48:../Generated_Code/SPI.c **** **            Auto initialization                          : no
  49:../Generated_Code/SPI.c **** **            Event mask                                   : 
  50:../Generated_Code/SPI.c **** **              OnBlockSent                                : Enabled
  51:../Generated_Code/SPI.c **** **              OnBlockReceived                            : Enabled
  52:../Generated_Code/SPI.c **** **              OnError                                    : Disabled
  53:../Generated_Code/SPI.c **** **          CPU clock/configuration selection              : 
  54:../Generated_Code/SPI.c **** **            Clock configuration 0                        : This component enabled
  55:../Generated_Code/SPI.c **** **            Clock configuration 1                        : This component disabled
  56:../Generated_Code/SPI.c **** **            Clock configuration 2                        : This component disabled
  57:../Generated_Code/SPI.c **** **            Clock configuration 3                        : This component disabled
  58:../Generated_Code/SPI.c **** **            Clock configuration 4                        : This component disabled
  59:../Generated_Code/SPI.c **** **            Clock configuration 5                        : This component disabled
  60:../Generated_Code/SPI.c **** **            Clock configuration 6                        : This component disabled
  61:../Generated_Code/SPI.c **** **            Clock configuration 7                        : This component disabled
  62:../Generated_Code/SPI.c **** **     Contents    :
  63:../Generated_Code/SPI.c **** **         Init               - LDD_TDeviceData* SPI_Init(LDD_TUserData *UserDataPtr);
  64:../Generated_Code/SPI.c **** **         SendBlock          - LDD_TError SPI_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData.
  65:../Generated_Code/SPI.c **** **         ReceiveBlock       - LDD_TError SPI_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TDa
  66:../Generated_Code/SPI.c **** **         GetBlockSentStatus - bool SPI_GetBlockSentStatus(LDD_TDeviceData *DeviceDataPtr);
  67:../Generated_Code/SPI.c **** **         Main               - void SPI_Main(LDD_TDeviceData *DeviceDataPtr);
  68:../Generated_Code/SPI.c **** **
  69:../Generated_Code/SPI.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  70:../Generated_Code/SPI.c **** **     All Rights Reserved.
  71:../Generated_Code/SPI.c **** **     
  72:../Generated_Code/SPI.c **** **     Redistribution and use in source and binary forms, with or without modification,
  73:../Generated_Code/SPI.c **** **     are permitted provided that the following conditions are met:
  74:../Generated_Code/SPI.c **** **     
  75:../Generated_Code/SPI.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  76:../Generated_Code/SPI.c **** **       of conditions and the following disclaimer.
  77:../Generated_Code/SPI.c **** **     
  78:../Generated_Code/SPI.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  79:../Generated_Code/SPI.c **** **       list of conditions and the following disclaimer in the documentation and/or
  80:../Generated_Code/SPI.c **** **       other materials provided with the distribution.
  81:../Generated_Code/SPI.c **** **     
  82:../Generated_Code/SPI.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  83:../Generated_Code/SPI.c **** **       contributors may be used to endorse or promote products derived from this
  84:../Generated_Code/SPI.c **** **       software without specific prior written permission.
  85:../Generated_Code/SPI.c **** **     
  86:../Generated_Code/SPI.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  87:../Generated_Code/SPI.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  88:../Generated_Code/SPI.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  89:../Generated_Code/SPI.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  90:../Generated_Code/SPI.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  91:../Generated_Code/SPI.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  92:../Generated_Code/SPI.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  93:../Generated_Code/SPI.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  94:../Generated_Code/SPI.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  95:../Generated_Code/SPI.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  96:../Generated_Code/SPI.c **** **     
  97:../Generated_Code/SPI.c **** **     http: www.freescale.com
  98:../Generated_Code/SPI.c **** **     mail: support@freescale.com
  99:../Generated_Code/SPI.c **** ** ###################################################################*/
 100:../Generated_Code/SPI.c **** /*!
 101:../Generated_Code/SPI.c **** ** @file SPI.c
 102:../Generated_Code/SPI.c **** ** @version 01.02
 103:../Generated_Code/SPI.c **** ** @brief
 104:../Generated_Code/SPI.c **** **         This component "SPIMaster_LDD" implements MASTER part of synchronous
 105:../Generated_Code/SPI.c **** **         serial master-slave communication.
 106:../Generated_Code/SPI.c **** */         
 107:../Generated_Code/SPI.c **** /*!
 108:../Generated_Code/SPI.c **** **  @addtogroup SPI_module SPI module documentation
 109:../Generated_Code/SPI.c **** **  @{
 110:../Generated_Code/SPI.c **** */         
 111:../Generated_Code/SPI.c **** 
 112:../Generated_Code/SPI.c **** /* MODULE SPI. */
 113:../Generated_Code/SPI.c **** /*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
 114:../Generated_Code/SPI.c **** 
 115:../Generated_Code/SPI.c **** #include "Events.h"
 116:../Generated_Code/SPI.c **** #include "SPI.h"
 117:../Generated_Code/SPI.c **** /* {Default RTOS Adapter} No RTOS includes */
 118:../Generated_Code/SPI.c **** 
 119:../Generated_Code/SPI.c **** #ifdef __cplusplus
 120:../Generated_Code/SPI.c **** extern "C" {
 121:../Generated_Code/SPI.c **** #endif 
 122:../Generated_Code/SPI.c **** 
 123:../Generated_Code/SPI.c **** #define AVAILABLE_EVENTS_MASK (LDD_SPIMASTER_ON_BLOCK_RECEIVED | LDD_SPIMASTER_ON_BLOCK_SENT)
 124:../Generated_Code/SPI.c **** 
 125:../Generated_Code/SPI.c **** /* These constants contain pins masks */
 126:../Generated_Code/SPI.c **** #define SPI_AVAILABLE_PIN_MASK (LDD_SPIMASTER_INPUT_PIN | LDD_SPIMASTER_OUTPUT_PIN | LDD_SPIMASTER_
 127:../Generated_Code/SPI.c **** #define BLOCK_SENT      0x01U          /* Data block sent flag */
 128:../Generated_Code/SPI.c **** #define BLOCK_RECEIVED  0x02U          /* Data block received flag */
 129:../Generated_Code/SPI.c **** 
 130:../Generated_Code/SPI.c **** typedef struct {
 131:../Generated_Code/SPI.c ****   LDD_SPIMASTER_TError ErrFlag;        /* Error flags */
 132:../Generated_Code/SPI.c ****   uint16_t InpRecvDataNum;             /* The counter of received characters */
 133:../Generated_Code/SPI.c ****   uint8_t *InpDataPtr;                 /* The buffer pointer for received characters */
 134:../Generated_Code/SPI.c ****   uint16_t InpDataNumReq;              /* The counter of characters to receive by ReceiveBlock() */
 135:../Generated_Code/SPI.c ****   uint16_t OutSentDataNum;             /* The counter of sent characters */
 136:../Generated_Code/SPI.c ****   uint8_t *OutDataPtr;                 /* The buffer pointer for data to be transmitted */
 137:../Generated_Code/SPI.c ****   uint16_t OutDataNumReq;              /* The counter of characters to be send by SendBlock() */
 138:../Generated_Code/SPI.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 139:../Generated_Code/SPI.c ****   LDD_TUserData *UserData;             /* User device data structure */
 140:../Generated_Code/SPI.c **** } SPI_TDeviceData;                     /* Device data structure type */
 141:../Generated_Code/SPI.c **** 
 142:../Generated_Code/SPI.c **** typedef SPI_TDeviceData* SPI_TDeviceDataPtr; /* Pointer to the device data structure */
 143:../Generated_Code/SPI.c **** 
 144:../Generated_Code/SPI.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 145:../Generated_Code/SPI.c **** static SPI_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 146:../Generated_Code/SPI.c **** /* Internal method prototypes */
 147:../Generated_Code/SPI.c **** 
 148:../Generated_Code/SPI.c **** /*
 149:../Generated_Code/SPI.c **** ** ===================================================================
 150:../Generated_Code/SPI.c **** **     Method      :  SPI_Init (component SPIMaster_LDD)
 151:../Generated_Code/SPI.c **** */
 152:../Generated_Code/SPI.c **** /*!
 153:../Generated_Code/SPI.c **** **     @brief
 154:../Generated_Code/SPI.c **** **         Initializes the device. Allocates memory for the device data
 155:../Generated_Code/SPI.c **** **         structure, allocates interrupt vectors and sets interrupt
 156:../Generated_Code/SPI.c **** **         priority, sets pin routing, sets timing, etc.
 157:../Generated_Code/SPI.c **** **         If the "Enable in init. code" is set to "yes" value then the
 158:../Generated_Code/SPI.c **** **         device is also enabled(see the description of the Enable()
 159:../Generated_Code/SPI.c **** **         method). In this case the Enable() method is not necessary
 160:../Generated_Code/SPI.c **** **         and needn't to be generated. 
 161:../Generated_Code/SPI.c **** **         This method can be called only once. Before the second call
 162:../Generated_Code/SPI.c **** **         of Init() the Deinit() must be called first.
 163:../Generated_Code/SPI.c **** **     @param
 164:../Generated_Code/SPI.c **** **         UserDataPtr     - Pointer to the user or
 165:../Generated_Code/SPI.c **** **                           RTOS specific data. This pointer will be
 166:../Generated_Code/SPI.c **** **                           passed as an event or callback parameter.
 167:../Generated_Code/SPI.c **** **     @return
 168:../Generated_Code/SPI.c **** **                         - Device data structure pointer.
 169:../Generated_Code/SPI.c **** */
 170:../Generated_Code/SPI.c **** /* ===================================================================*/
 171:../Generated_Code/SPI.c **** LDD_TDeviceData* SPI_Init(LDD_TUserData *UserDataPtr)
 172:../Generated_Code/SPI.c **** {
  32              		.loc 1 172 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              	.LCFI2:
  44              		.cfi_def_cfa_register 7
  45 0006 7860     		str	r0, [r7, #4]
 173:../Generated_Code/SPI.c ****   /* Allocate LDD device structure */
 174:../Generated_Code/SPI.c ****   SPI_TDeviceDataPtr DeviceDataPrv;
 175:../Generated_Code/SPI.c **** 
 176:../Generated_Code/SPI.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 177:../Generated_Code/SPI.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  46              		.loc 1 177 0
  47 0008 2C4B     		ldr	r3, .L3
  48 000a FB60     		str	r3, [r7, #12]
 178:../Generated_Code/SPI.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  49              		.loc 1 178 0
  50 000c FB68     		ldr	r3, [r7, #12]
  51 000e 7A68     		ldr	r2, [r7, #4]
  52 0010 9A61     		str	r2, [r3, #24]
 179:../Generated_Code/SPI.c ****   DeviceDataPrv->ErrFlag = 0x00U;      /* Clear error flags */
  53              		.loc 1 179 0
  54 0012 FB68     		ldr	r3, [r7, #12]
  55 0014 0022     		mov	r2, #0
  56 0016 1A60     		str	r2, [r3]
 180:../Generated_Code/SPI.c ****   /* Clear the receive counters and pointer */
 181:../Generated_Code/SPI.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  57              		.loc 1 181 0
  58 0018 FB68     		ldr	r3, [r7, #12]
  59 001a 0022     		mov	r2, #0
  60 001c 9A80     		strh	r2, [r3, #4]
 182:../Generated_Code/SPI.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  61              		.loc 1 182 0
  62 001e FB68     		ldr	r3, [r7, #12]
  63 0020 0022     		mov	r2, #0
  64 0022 9A81     		strh	r2, [r3, #12]
 183:../Generated_Code/SPI.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  65              		.loc 1 183 0
  66 0024 FB68     		ldr	r3, [r7, #12]
  67 0026 0022     		mov	r2, #0
  68 0028 9A60     		str	r2, [r3, #8]
 184:../Generated_Code/SPI.c ****   /* Clear the transmit counters and pointer */
 185:../Generated_Code/SPI.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  69              		.loc 1 185 0
  70 002a FB68     		ldr	r3, [r7, #12]
  71 002c 0022     		mov	r2, #0
  72 002e DA81     		strh	r2, [r3, #14]
 186:../Generated_Code/SPI.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  73              		.loc 1 186 0
  74 0030 FB68     		ldr	r3, [r7, #12]
  75 0032 0022     		mov	r2, #0
  76 0034 9A82     		strh	r2, [r3, #20]
 187:../Generated_Code/SPI.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  77              		.loc 1 187 0
  78 0036 FB68     		ldr	r3, [r7, #12]
  79 0038 0022     		mov	r2, #0
  80 003a 1A61     		str	r2, [r3, #16]
 188:../Generated_Code/SPI.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
  81              		.loc 1 188 0
  82 003c FB68     		ldr	r3, [r7, #12]
  83 003e 0022     		mov	r2, #0
  84 0040 9A75     		strb	r2, [r3, #22]
 189:../Generated_Code/SPI.c ****   /* SIM_SCGC4: SPI0=1 */
 190:../Generated_Code/SPI.c ****   SIM_SCGC4 |= SIM_SCGC4_SPI0_MASK;
  85              		.loc 1 190 0
  86 0042 1F4A     		ldr	r2, .L3+4
  87 0044 1E49     		ldr	r1, .L3+4
  88 0046 1F4B     		ldr	r3, .L3+8
  89 0048 CB58     		ldr	r3, [r1, r3]
  90 004a 8021     		mov	r1, #128
  91 004c C903     		lsl	r1, r1, #15
  92 004e 1943     		orr	r1, r3
  93 0050 1C4B     		ldr	r3, .L3+8
  94 0052 D150     		str	r1, [r2, r3]
 191:../Generated_Code/SPI.c ****   /* PORTD_PCR2: ISF=0,MUX=5 */
 192:../Generated_Code/SPI.c ****   PORTD_PCR2 = (uint32_t)((PORTD_PCR2 & (uint32_t)~(uint32_t)(
  95              		.loc 1 192 0
  96 0054 1C4B     		ldr	r3, .L3+12
  97 0056 1C4A     		ldr	r2, .L3+12
  98 0058 9168     		ldr	r1, [r2, #8]
  99 005a 1C4A     		ldr	r2, .L3+16
 100 005c 0A40     		and	r2, r1
 101 005e A021     		mov	r1, #160
 102 0060 C900     		lsl	r1, r1, #3
 103 0062 0A43     		orr	r2, r1
 104 0064 9A60     		str	r2, [r3, #8]
 193:../Generated_Code/SPI.c ****                 PORT_PCR_ISF_MASK |
 194:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x02)
 195:../Generated_Code/SPI.c ****                )) | (uint32_t)(
 196:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x05)
 197:../Generated_Code/SPI.c ****                ));
 198:../Generated_Code/SPI.c ****   /* PORTD_PCR3: ISF=0,MUX=5 */
 199:../Generated_Code/SPI.c ****   PORTD_PCR3 = (uint32_t)((PORTD_PCR3 & (uint32_t)~(uint32_t)(
 105              		.loc 1 199 0
 106 0066 184B     		ldr	r3, .L3+12
 107 0068 174A     		ldr	r2, .L3+12
 108 006a D168     		ldr	r1, [r2, #12]
 109 006c 174A     		ldr	r2, .L3+16
 110 006e 0A40     		and	r2, r1
 111 0070 A021     		mov	r1, #160
 112 0072 C900     		lsl	r1, r1, #3
 113 0074 0A43     		orr	r2, r1
 114 0076 DA60     		str	r2, [r3, #12]
 200:../Generated_Code/SPI.c ****                 PORT_PCR_ISF_MASK |
 201:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x02)
 202:../Generated_Code/SPI.c ****                )) | (uint32_t)(
 203:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x05)
 204:../Generated_Code/SPI.c ****                ));
 205:../Generated_Code/SPI.c ****   /* PORTD_PCR1: ISF=0,MUX=2 */
 206:../Generated_Code/SPI.c ****   PORTD_PCR1 = (uint32_t)((PORTD_PCR1 & (uint32_t)~(uint32_t)(
 115              		.loc 1 206 0
 116 0078 134B     		ldr	r3, .L3+12
 117 007a 134A     		ldr	r2, .L3+12
 118 007c 5168     		ldr	r1, [r2, #4]
 119 007e 134A     		ldr	r2, .L3+16
 120 0080 0A40     		and	r2, r1
 121 0082 8021     		mov	r1, #128
 122 0084 8900     		lsl	r1, r1, #2
 123 0086 0A43     		orr	r2, r1
 124 0088 5A60     		str	r2, [r3, #4]
 207:../Generated_Code/SPI.c ****                 PORT_PCR_ISF_MASK |
 208:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x05)
 209:../Generated_Code/SPI.c ****                )) | (uint32_t)(
 210:../Generated_Code/SPI.c ****                 PORT_PCR_MUX(0x02)
 211:../Generated_Code/SPI.c ****                ));
 212:../Generated_Code/SPI.c ****   /* SPI0_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=1,CPOL=0,CPHA=0,SSOE=1,LSBFE=0 */
 213:../Generated_Code/SPI.c ****   SPI0_C1 = (SPI_C1_MSTR_MASK | SPI_C1_SSOE_MASK); /* Set configuration register */
 125              		.loc 1 213 0
 126 008a 114B     		ldr	r3, .L3+20
 127 008c 1222     		mov	r2, #18
 128 008e 1A70     		strb	r2, [r3]
 214:../Generated_Code/SPI.c ****   /* SPI0_C2: SPMIE=0,??=0,TXDMAE=0,MODFEN=1,BIDIROE=0,RXDMAE=0,SPISWAI=0,SPC0=0 */
 215:../Generated_Code/SPI.c ****   SPI0_C2 = SPI_C2_MODFEN_MASK;        /* Set configuration register */
 129              		.loc 1 215 0
 130 0090 0F4B     		ldr	r3, .L3+20
 131 0092 1022     		mov	r2, #16
 132 0094 5A70     		strb	r2, [r3, #1]
 216:../Generated_Code/SPI.c ****   /* SPI0_BR: ??=0,SPPR=2,SPR=2 */
 217:../Generated_Code/SPI.c ****   SPI0_BR = (SPI_BR_SPPR(0x02) | SPI_BR_SPR(0x02)); /* Set baud rate register */
 133              		.loc 1 217 0
 134 0096 0E4B     		ldr	r3, .L3+20
 135 0098 2222     		mov	r2, #34
 136 009a 9A70     		strb	r2, [r3, #2]
 218:../Generated_Code/SPI.c ****   /* SPI0_C1: SPE=1 */
 219:../Generated_Code/SPI.c ****   SPI0_C1 |= SPI_C1_SPE_MASK;          /* Enable SPI module */
 137              		.loc 1 219 0
 138 009c 0C4B     		ldr	r3, .L3+20
 139 009e 0C4A     		ldr	r2, .L3+20
 140 00a0 1278     		ldrb	r2, [r2]
 141 00a2 D2B2     		uxtb	r2, r2
 142 00a4 4021     		mov	r1, #64
 143 00a6 0A43     		orr	r2, r1
 144 00a8 D2B2     		uxtb	r2, r2
 145 00aa 1A70     		strb	r2, [r3]
 220:../Generated_Code/SPI.c ****   /* Registration of the device structure */
 221:../Generated_Code/SPI.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SPI_ID,DeviceDataPrv);
 146              		.loc 1 221 0
 147 00ac 094B     		ldr	r3, .L3+24
 148 00ae FA68     		ldr	r2, [r7, #12]
 149 00b0 9A60     		str	r2, [r3, #8]
 222:../Generated_Code/SPI.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 150              		.loc 1 222 0
 151 00b2 FB68     		ldr	r3, [r7, #12]
 223:../Generated_Code/SPI.c **** }
 152              		.loc 1 223 0
 153 00b4 181C     		mov	r0, r3
 154 00b6 BD46     		mov	sp, r7
 155 00b8 04B0     		add	sp, sp, #16
 156              		@ sp needed for prologue
 157 00ba 80BD     		pop	{r7, pc}
 158              	.L4:
 159              		.align	2
 160              	.L3:
 161 00bc 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 162 00c0 00700440 		.word	1074032640
 163 00c4 34100000 		.word	4148
 164 00c8 00C00440 		.word	1074053120
 165 00cc FFF8FFFE 		.word	-16779009
 166 00d0 00600740 		.word	1074225152
 167 00d4 00000000 		.word	PE_LDD_DeviceDataList
 168              		.cfi_endproc
 169              	.LFE0:
 171              		.section	.text.SPI_ReceiveBlock,"ax",%progbits
 172              		.align	2
 173              		.global	SPI_ReceiveBlock
 174              		.code	16
 175              		.thumb_func
 177              	SPI_ReceiveBlock:
 178              	.LFB1:
 224:../Generated_Code/SPI.c **** 
 225:../Generated_Code/SPI.c **** /*
 226:../Generated_Code/SPI.c **** ** ===================================================================
 227:../Generated_Code/SPI.c **** **     Method      :  SPI_ReceiveBlock (component SPIMaster_LDD)
 228:../Generated_Code/SPI.c **** */
 229:../Generated_Code/SPI.c **** /*!
 230:../Generated_Code/SPI.c **** **     @brief
 231:../Generated_Code/SPI.c **** **         This method specifies the number of data to receive. The
 232:../Generated_Code/SPI.c **** **         method returns ERR_BUSY until the specified number of
 233:../Generated_Code/SPI.c **** **         characters is received. The method <CancelBlockReception>
 234:../Generated_Code/SPI.c **** **         can be used to cancel a running receive operation.
 235:../Generated_Code/SPI.c **** **     @param
 236:../Generated_Code/SPI.c **** **         DeviceDataPtr   - Device data structure
 237:../Generated_Code/SPI.c **** **                           pointer returned by <Init> method.
 238:../Generated_Code/SPI.c **** **     @param
 239:../Generated_Code/SPI.c **** **         BufferPtr       - Pointer to A buffer where
 240:../Generated_Code/SPI.c **** **                           received characters will be stored.
 241:../Generated_Code/SPI.c **** **     @param
 242:../Generated_Code/SPI.c **** **         Size            - Size of the block
 243:../Generated_Code/SPI.c **** **     @return
 244:../Generated_Code/SPI.c **** **                         - Error code, possible codes:
 245:../Generated_Code/SPI.c **** **                           ERR_OK - OK
 246:../Generated_Code/SPI.c **** **                           ERR_SPEED - This device does not work in
 247:../Generated_Code/SPI.c **** **                           the active clock configuration
 248:../Generated_Code/SPI.c **** **                           ERR_DISABLED - Component is disabled
 249:../Generated_Code/SPI.c **** **                           ERR_BUSY - The previous receive request is
 250:../Generated_Code/SPI.c **** **                           pending
 251:../Generated_Code/SPI.c **** */
 252:../Generated_Code/SPI.c **** /* ===================================================================*/
 253:../Generated_Code/SPI.c **** LDD_TError SPI_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 254:../Generated_Code/SPI.c **** {
 179              		.loc 1 254 0
 180              		.cfi_startproc
 181 0000 80B5     		push	{r7, lr}
 182              	.LCFI3:
 183              		.cfi_def_cfa_offset 8
 184              		.cfi_offset 7, -8
 185              		.cfi_offset 14, -4
 186 0002 84B0     		sub	sp, sp, #16
 187              	.LCFI4:
 188              		.cfi_def_cfa_offset 24
 189 0004 00AF     		add	r7, sp, #0
 190              	.LCFI5:
 191              		.cfi_def_cfa_register 7
 192 0006 F860     		str	r0, [r7, #12]
 193 0008 B960     		str	r1, [r7, #8]
 194 000a BB1D     		add	r3, r7, #6
 195 000c 1A80     		strh	r2, [r3]
 255:../Generated_Code/SPI.c ****   if (((SPI_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq != 0x00U) { /* Is the previous receive ope
 196              		.loc 1 255 0
 197 000e FB68     		ldr	r3, [r7, #12]
 198 0010 9B89     		ldrh	r3, [r3, #12]
 199 0012 002B     		cmp	r3, #0
 200 0014 01D0     		beq	.L6
 256:../Generated_Code/SPI.c ****     return ERR_BUSY;                   /* If yes then error */
 201              		.loc 1 256 0
 202 0016 0823     		mov	r3, #8
 203 0018 1AE0     		b	.L7
 204              	.L6:
 257:../Generated_Code/SPI.c ****   }
 258:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->InpDataPtr = (uint8_t*)BufferPtr; /* Store a pointer to the 
 205              		.loc 1 258 0
 206 001a FB68     		ldr	r3, [r7, #12]
 207 001c BA68     		ldr	r2, [r7, #8]
 208 001e 9A60     		str	r2, [r3, #8]
 259:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq = Size; /* Store a number of characters to be 
 209              		.loc 1 259 0
 210 0020 FB68     		ldr	r3, [r7, #12]
 211 0022 BA1D     		add	r2, r7, #6
 212 0024 1288     		ldrh	r2, [r2]
 213 0026 9A81     		strh	r2, [r3, #12]
 260:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum = 0x00U; /* Set number of received characters
 214              		.loc 1 260 0
 215 0028 FB68     		ldr	r3, [r7, #12]
 216 002a 0022     		mov	r2, #0
 217 002c 9A80     		strh	r2, [r3, #4]
 261:../Generated_Code/SPI.c ****   if ((SPI_PDD_ReadStatusReg(SPI0_BASE_PTR) & SPI_PDD_RX_BUFFER_FULL) != 0U) {
 218              		.loc 1 261 0
 219 002e 0A4B     		ldr	r3, .L9
 220 0030 DB78     		ldrb	r3, [r3, #3]
 221 0032 DBB2     		uxtb	r3, r3
 222 0034 DBB2     		uxtb	r3, r3
 223 0036 5BB2     		sxtb	r3, r3
 224 0038 002B     		cmp	r3, #0
 225 003a 01DA     		bge	.L8
 262:../Generated_Code/SPI.c ****     (void)SPI_PDD_ReadData8bit(SPI0_BASE_PTR); /* Dummy read of the data register */
 226              		.loc 1 262 0
 227 003c 064B     		ldr	r3, .L9
 228 003e 5B79     		ldrb	r3, [r3, #5]
 229              	.L8:
 263:../Generated_Code/SPI.c ****   }
 264:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_RECEIVED); /* Clear dat
 230              		.loc 1 264 0
 231 0040 FB68     		ldr	r3, [r7, #12]
 232 0042 9B7D     		ldrb	r3, [r3, #22]
 233 0044 0222     		mov	r2, #2
 234 0046 9343     		bic	r3, r2
 235 0048 DAB2     		uxtb	r2, r3
 236 004a FB68     		ldr	r3, [r7, #12]
 237 004c 9A75     		strb	r2, [r3, #22]
 265:../Generated_Code/SPI.c ****   return ERR_OK;                       /* OK */
 238              		.loc 1 265 0
 239 004e 0023     		mov	r3, #0
 240              	.L7:
 266:../Generated_Code/SPI.c **** }
 241              		.loc 1 266 0
 242 0050 181C     		mov	r0, r3
 243 0052 BD46     		mov	sp, r7
 244 0054 04B0     		add	sp, sp, #16
 245              		@ sp needed for prologue
 246 0056 80BD     		pop	{r7, pc}
 247              	.L10:
 248              		.align	2
 249              	.L9:
 250 0058 00600740 		.word	1074225152
 251              		.cfi_endproc
 252              	.LFE1:
 254              		.section	.text.SPI_SendBlock,"ax",%progbits
 255              		.align	2
 256              		.global	SPI_SendBlock
 257              		.code	16
 258              		.thumb_func
 260              	SPI_SendBlock:
 261              	.LFB2:
 267:../Generated_Code/SPI.c **** 
 268:../Generated_Code/SPI.c **** /*
 269:../Generated_Code/SPI.c **** ** ===================================================================
 270:../Generated_Code/SPI.c **** **     Method      :  SPI_SendBlock (component SPIMaster_LDD)
 271:../Generated_Code/SPI.c **** */
 272:../Generated_Code/SPI.c **** /*!
 273:../Generated_Code/SPI.c **** **     @brief
 274:../Generated_Code/SPI.c **** **         This method sends a block of characters. The method returns
 275:../Generated_Code/SPI.c **** **         ERR_BUSY when the previous block transmission is not
 276:../Generated_Code/SPI.c **** **         completed. The method <CancelBlockTransmission> can be used
 277:../Generated_Code/SPI.c **** **         to cancel a transmit operation.
 278:../Generated_Code/SPI.c **** **     @param
 279:../Generated_Code/SPI.c **** **         DeviceDataPtr   - Device data structure
 280:../Generated_Code/SPI.c **** **                           pointer returned by <Init> method.
 281:../Generated_Code/SPI.c **** **     @param
 282:../Generated_Code/SPI.c **** **         BufferPtr       - Pointer to the block of data
 283:../Generated_Code/SPI.c **** **                           to send.
 284:../Generated_Code/SPI.c **** **     @param
 285:../Generated_Code/SPI.c **** **         Size            - Number of characters in the buffer.
 286:../Generated_Code/SPI.c **** **     @return
 287:../Generated_Code/SPI.c **** **                         - Error code, possible codes:
 288:../Generated_Code/SPI.c **** **                           ERR_OK - OK
 289:../Generated_Code/SPI.c **** **                           ERR_SPEED - This device does not work in
 290:../Generated_Code/SPI.c **** **                           the active clock configuration
 291:../Generated_Code/SPI.c **** **                           ERR_DISABLED - Component is disabled
 292:../Generated_Code/SPI.c **** **                           ERR_BUSY - The previous transmit request is
 293:../Generated_Code/SPI.c **** **                           pending
 294:../Generated_Code/SPI.c **** */
 295:../Generated_Code/SPI.c **** /* ===================================================================*/
 296:../Generated_Code/SPI.c **** LDD_TError SPI_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 297:../Generated_Code/SPI.c **** {
 262              		.loc 1 297 0
 263              		.cfi_startproc
 264 0000 80B5     		push	{r7, lr}
 265              	.LCFI6:
 266              		.cfi_def_cfa_offset 8
 267              		.cfi_offset 7, -8
 268              		.cfi_offset 14, -4
 269 0002 84B0     		sub	sp, sp, #16
 270              	.LCFI7:
 271              		.cfi_def_cfa_offset 24
 272 0004 00AF     		add	r7, sp, #0
 273              	.LCFI8:
 274              		.cfi_def_cfa_register 7
 275 0006 F860     		str	r0, [r7, #12]
 276 0008 B960     		str	r1, [r7, #8]
 277 000a BB1D     		add	r3, r7, #6
 278 000c 1A80     		strh	r2, [r3]
 298:../Generated_Code/SPI.c ****   if (((SPI_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq != 0x00U) { /* Is the previous transmit op
 279              		.loc 1 298 0
 280 000e FB68     		ldr	r3, [r7, #12]
 281 0010 9B8A     		ldrh	r3, [r3, #20]
 282 0012 002B     		cmp	r3, #0
 283 0014 01D0     		beq	.L12
 299:../Generated_Code/SPI.c ****     return ERR_BUSY;                   /* If yes then error */
 284              		.loc 1 299 0
 285 0016 0823     		mov	r3, #8
 286 0018 11E0     		b	.L13
 287              	.L12:
 300:../Generated_Code/SPI.c ****   }
 301:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->OutDataPtr = (uint8_t*)BufferPtr; /* Set a pointer to the ou
 288              		.loc 1 301 0
 289 001a FB68     		ldr	r3, [r7, #12]
 290 001c BA68     		ldr	r2, [r7, #8]
 291 001e 1A61     		str	r2, [r3, #16]
 302:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq = Size; /* Set the counter of characters to be
 292              		.loc 1 302 0
 293 0020 FB68     		ldr	r3, [r7, #12]
 294 0022 BA1D     		add	r2, r7, #6
 295 0024 1288     		ldrh	r2, [r2]
 296 0026 9A82     		strh	r2, [r3, #20]
 303:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum = 0x00U; /* Clear the counter of sent charact
 297              		.loc 1 303 0
 298 0028 FB68     		ldr	r3, [r7, #12]
 299 002a 0022     		mov	r2, #0
 300 002c DA81     		strh	r2, [r3, #14]
 304:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_SENT); /* Clear data bl
 301              		.loc 1 304 0
 302 002e FB68     		ldr	r3, [r7, #12]
 303 0030 9B7D     		ldrb	r3, [r3, #22]
 304 0032 0122     		mov	r2, #1
 305 0034 9343     		bic	r3, r2
 306 0036 DAB2     		uxtb	r2, r3
 307 0038 FB68     		ldr	r3, [r7, #12]
 308 003a 9A75     		strb	r2, [r3, #22]
 305:../Generated_Code/SPI.c ****   return ERR_OK;                       /* OK */
 309              		.loc 1 305 0
 310 003c 0023     		mov	r3, #0
 311              	.L13:
 306:../Generated_Code/SPI.c **** }
 312              		.loc 1 306 0
 313 003e 181C     		mov	r0, r3
 314 0040 BD46     		mov	sp, r7
 315 0042 04B0     		add	sp, sp, #16
 316              		@ sp needed for prologue
 317 0044 80BD     		pop	{r7, pc}
 318              		.cfi_endproc
 319              	.LFE2:
 321 0046 C046     		.section	.text.SPI_GetBlockSentStatus,"ax",%progbits
 322              		.align	2
 323              		.global	SPI_GetBlockSentStatus
 324              		.code	16
 325              		.thumb_func
 327              	SPI_GetBlockSentStatus:
 328              	.LFB3:
 307:../Generated_Code/SPI.c **** 
 308:../Generated_Code/SPI.c **** /*
 309:../Generated_Code/SPI.c **** ** ===================================================================
 310:../Generated_Code/SPI.c **** **     Method      :  SPI_GetBlockSentStatus (component SPIMaster_LDD)
 311:../Generated_Code/SPI.c **** */
 312:../Generated_Code/SPI.c **** /*!
 313:../Generated_Code/SPI.c **** **     @brief
 314:../Generated_Code/SPI.c **** **         This method returns whether the transmitter is finished
 315:../Generated_Code/SPI.c **** **         transmitting all data block. The status flag is accumulated,
 316:../Generated_Code/SPI.c **** **         after calling this method the status is returned and cleared
 317:../Generated_Code/SPI.c **** **         (set to "false" state). This method is available only if
 318:../Generated_Code/SPI.c **** **         method SendBlock is enabled.
 319:../Generated_Code/SPI.c **** **     @param
 320:../Generated_Code/SPI.c **** **         DeviceDataPtr   - Device data structure
 321:../Generated_Code/SPI.c **** **                           pointer returned by <Init> method.
 322:../Generated_Code/SPI.c **** **     @return
 323:../Generated_Code/SPI.c **** **                         - Return value:
 324:../Generated_Code/SPI.c **** **                           true - Data block is completely transmitted
 325:../Generated_Code/SPI.c **** **                           false - Data block isn't completely
 326:../Generated_Code/SPI.c **** **                           transmitted.
 327:../Generated_Code/SPI.c **** */
 328:../Generated_Code/SPI.c **** /* ===================================================================*/
 329:../Generated_Code/SPI.c **** bool SPI_GetBlockSentStatus(LDD_TDeviceData *DeviceDataPtr)
 330:../Generated_Code/SPI.c **** {
 329              		.loc 1 330 0
 330              		.cfi_startproc
 331 0000 80B5     		push	{r7, lr}
 332              	.LCFI9:
 333              		.cfi_def_cfa_offset 8
 334              		.cfi_offset 7, -8
 335              		.cfi_offset 14, -4
 336 0002 84B0     		sub	sp, sp, #16
 337              	.LCFI10:
 338              		.cfi_def_cfa_offset 24
 339 0004 00AF     		add	r7, sp, #0
 340              	.LCFI11:
 341              		.cfi_def_cfa_register 7
 342 0006 7860     		str	r0, [r7, #4]
 331:../Generated_Code/SPI.c ****   uint8_t Status;                      /* Temporary variable for flag saving */
 332:../Generated_Code/SPI.c **** 
 333:../Generated_Code/SPI.c ****   Status = ((SPI_TDeviceDataPtr)DeviceDataPtr)->SerFlag; /* Save flag for return */
 343              		.loc 1 333 0
 344 0008 3B1C     		mov	r3, r7
 345 000a 0F33     		add	r3, r3, #15
 346 000c 7A68     		ldr	r2, [r7, #4]
 347 000e 927D     		ldrb	r2, [r2, #22]
 348 0010 1A70     		strb	r2, [r3]
 334:../Generated_Code/SPI.c ****   ((SPI_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_SENT); /* Clear data bl
 349              		.loc 1 334 0
 350 0012 7B68     		ldr	r3, [r7, #4]
 351 0014 9B7D     		ldrb	r3, [r3, #22]
 352 0016 0122     		mov	r2, #1
 353 0018 9343     		bic	r3, r2
 354 001a DAB2     		uxtb	r2, r3
 355 001c 7B68     		ldr	r3, [r7, #4]
 356 001e 9A75     		strb	r2, [r3, #22]
 335:../Generated_Code/SPI.c ****   return (bool)(((Status & BLOCK_SENT) != 0U)? TRUE : FALSE); /* Return saved status */
 357              		.loc 1 335 0
 358 0020 3B1C     		mov	r3, r7
 359 0022 0F33     		add	r3, r3, #15
 360 0024 1A78     		ldrb	r2, [r3]
 361 0026 0123     		mov	r3, #1
 362 0028 1340     		and	r3, r2
 363 002a DBB2     		uxtb	r3, r3
 336:../Generated_Code/SPI.c **** }
 364              		.loc 1 336 0
 365 002c 181C     		mov	r0, r3
 366 002e BD46     		mov	sp, r7
 367 0030 04B0     		add	sp, sp, #16
 368              		@ sp needed for prologue
 369 0032 80BD     		pop	{r7, pc}
 370              		.cfi_endproc
 371              	.LFE3:
 373              		.section	.text.SPI_Main,"ax",%progbits
 374              		.align	2
 375              		.global	SPI_Main
 376              		.code	16
 377              		.thumb_func
 379              	SPI_Main:
 380              	.LFB4:
 337:../Generated_Code/SPI.c **** 
 338:../Generated_Code/SPI.c **** /*
 339:../Generated_Code/SPI.c **** ** ===================================================================
 340:../Generated_Code/SPI.c **** **     Method      :  SPI_Main (component SPIMaster_LDD)
 341:../Generated_Code/SPI.c **** */
 342:../Generated_Code/SPI.c **** /*!
 343:../Generated_Code/SPI.c **** **     @brief
 344:../Generated_Code/SPI.c **** **         This method is available only in the polling mode (Interrupt
 345:../Generated_Code/SPI.c **** **         service/event = 'no'). If interrupt service is disabled this
 346:../Generated_Code/SPI.c **** **         method replaces the interrupt handler. This method should be
 347:../Generated_Code/SPI.c **** **         called if Receive/SendBlock was invoked before in order to
 348:../Generated_Code/SPI.c **** **         run the reception/transmission. The end of the
 349:../Generated_Code/SPI.c **** **         receiving/transmitting is indicated by OnBlockSent or
 350:../Generated_Code/SPI.c **** **         OnBlockReceived event. 
 351:../Generated_Code/SPI.c **** **     @param
 352:../Generated_Code/SPI.c **** **         DeviceDataPtr   - Device data structure
 353:../Generated_Code/SPI.c **** **                           pointer returned by <Init> method.
 354:../Generated_Code/SPI.c **** */
 355:../Generated_Code/SPI.c **** /* ===================================================================*/
 356:../Generated_Code/SPI.c **** void SPI_Main(LDD_TDeviceData *DeviceDataPtr)
 357:../Generated_Code/SPI.c **** {
 381              		.loc 1 357 0
 382              		.cfi_startproc
 383 0000 80B5     		push	{r7, lr}
 384              	.LCFI12:
 385              		.cfi_def_cfa_offset 8
 386              		.cfi_offset 7, -8
 387              		.cfi_offset 14, -4
 388 0002 84B0     		sub	sp, sp, #16
 389              	.LCFI13:
 390              		.cfi_def_cfa_offset 24
 391 0004 00AF     		add	r7, sp, #0
 392              	.LCFI14:
 393              		.cfi_def_cfa_register 7
 394 0006 7860     		str	r0, [r7, #4]
 358:../Generated_Code/SPI.c ****   SPI_TDeviceDataPtr DeviceDataPrv = (SPI_TDeviceDataPtr)DeviceDataPtr;
 395              		.loc 1 358 0
 396 0008 7B68     		ldr	r3, [r7, #4]
 397 000a FB60     		str	r3, [r7, #12]
 359:../Generated_Code/SPI.c ****   uint8_t StatReg = SPI_PDD_ReadStatusReg(SPI0_BASE_PTR); /* Read status register */
 398              		.loc 1 359 0
 399 000c 2E4A     		ldr	r2, .L19
 400 000e 3B1C     		mov	r3, r7
 401 0010 0B33     		add	r3, r3, #11
 402 0012 D278     		ldrb	r2, [r2, #3]
 403 0014 1A70     		strb	r2, [r3]
 360:../Generated_Code/SPI.c **** 
 361:../Generated_Code/SPI.c ****   (void)DeviceDataPrv;                 /* Supress unused variable warning if needed */
 362:../Generated_Code/SPI.c ****   if ((StatReg & SPI_PDD_RX_BUFFER_FULL) != 0U) { /* Is any char in HW Rx buffer? */
 404              		.loc 1 362 0
 405 0016 3B1C     		mov	r3, r7
 406 0018 0B33     		add	r3, r3, #11
 407 001a 1B78     		ldrb	r3, [r3]
 408 001c 5BB2     		sxtb	r3, r3
 409 001e 002B     		cmp	r3, #0
 410 0020 20DA     		bge	.L17
 363:../Generated_Code/SPI.c ****     if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 411              		.loc 1 363 0
 412 0022 FB68     		ldr	r3, [r7, #12]
 413 0024 9B89     		ldrh	r3, [r3, #12]
 414 0026 002B     		cmp	r3, #0
 415 0028 1CD0     		beq	.L17
 364:../Generated_Code/SPI.c ****       *(DeviceDataPrv->InpDataPtr++) = SPI_PDD_ReadData8bit(SPI0_BASE_PTR); /* Put a character to t
 416              		.loc 1 364 0
 417 002a FB68     		ldr	r3, [r7, #12]
 418 002c 9B68     		ldr	r3, [r3, #8]
 419 002e 264A     		ldr	r2, .L19
 420 0030 5279     		ldrb	r2, [r2, #5]
 421 0032 D2B2     		uxtb	r2, r2
 422 0034 1A70     		strb	r2, [r3]
 423 0036 5A1C     		add	r2, r3, #1
 424 0038 FB68     		ldr	r3, [r7, #12]
 425 003a 9A60     		str	r2, [r3, #8]
 365:../Generated_Code/SPI.c ****       DeviceDataPrv->InpRecvDataNum++; /* Increment received char. counter */
 426              		.loc 1 365 0
 427 003c FB68     		ldr	r3, [r7, #12]
 428 003e 9B88     		ldrh	r3, [r3, #4]
 429 0040 0133     		add	r3, r3, #1
 430 0042 9AB2     		uxth	r2, r3
 431 0044 FB68     		ldr	r3, [r7, #12]
 432 0046 9A80     		strh	r2, [r3, #4]
 366:../Generated_Code/SPI.c ****       if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested numb
 433              		.loc 1 366 0
 434 0048 FB68     		ldr	r3, [r7, #12]
 435 004a 9A88     		ldrh	r2, [r3, #4]
 436 004c FB68     		ldr	r3, [r7, #12]
 437 004e 9B89     		ldrh	r3, [r3, #12]
 438 0050 9A42     		cmp	r2, r3
 439 0052 07D1     		bne	.L17
 367:../Generated_Code/SPI.c ****         DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters t
 440              		.loc 1 367 0
 441 0054 FB68     		ldr	r3, [r7, #12]
 442 0056 0022     		mov	r2, #0
 443 0058 9A81     		strh	r2, [r3, #12]
 368:../Generated_Code/SPI.c ****         SPI_OnBlockReceived(DeviceDataPrv->UserData);
 444              		.loc 1 368 0
 445 005a FB68     		ldr	r3, [r7, #12]
 446 005c 9B69     		ldr	r3, [r3, #24]
 447 005e 181C     		mov	r0, r3
 448 0060 FFF7FEFF 		bl	SPI_OnBlockReceived
 449              	.L17:
 369:../Generated_Code/SPI.c ****       }
 370:../Generated_Code/SPI.c ****     }
 371:../Generated_Code/SPI.c ****   }
 372:../Generated_Code/SPI.c ****   if ((StatReg & SPI_PDD_TX_BUFFER_EMPTYG) != 0U) { /* Is HW Tx buffer empty? */
 450              		.loc 1 372 0
 451 0064 3B1C     		mov	r3, r7
 452 0066 0B33     		add	r3, r3, #11
 453 0068 1A78     		ldrb	r2, [r3]
 454 006a 2023     		mov	r3, #32
 455 006c 1340     		and	r3, r2
 456 006e 28D0     		beq	.L16
 373:../Generated_Code/SPI.c ****     if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent charac
 457              		.loc 1 373 0
 458 0070 FB68     		ldr	r3, [r7, #12]
 459 0072 DA89     		ldrh	r2, [r3, #14]
 460 0074 FB68     		ldr	r3, [r7, #12]
 461 0076 9B8A     		ldrh	r3, [r3, #20]
 462 0078 9A42     		cmp	r2, r3
 463 007a 22D2     		bcs	.L16
 374:../Generated_Code/SPI.c ****       SPI_PDD_WriteData8Bit(SPI0_BASE_PTR, (*((uint8_t *)DeviceDataPrv->OutDataPtr++))); /* Put a c
 464              		.loc 1 374 0
 465 007c 124A     		ldr	r2, .L19
 466 007e FB68     		ldr	r3, [r7, #12]
 467 0080 1B69     		ldr	r3, [r3, #16]
 468 0082 1978     		ldrb	r1, [r3]
 469 0084 5171     		strb	r1, [r2, #5]
 470 0086 5A1C     		add	r2, r3, #1
 471 0088 FB68     		ldr	r3, [r7, #12]
 472 008a 1A61     		str	r2, [r3, #16]
 375:../Generated_Code/SPI.c ****       DeviceDataPrv->OutSentDataNum++; /* Increment the counter of sent characters. */
 473              		.loc 1 375 0
 474 008c FB68     		ldr	r3, [r7, #12]
 475 008e DB89     		ldrh	r3, [r3, #14]
 476 0090 0133     		add	r3, r3, #1
 477 0092 9AB2     		uxth	r2, r3
 478 0094 FB68     		ldr	r3, [r7, #12]
 479 0096 DA81     		strh	r2, [r3, #14]
 376:../Generated_Code/SPI.c ****       if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 480              		.loc 1 376 0
 481 0098 FB68     		ldr	r3, [r7, #12]
 482 009a DA89     		ldrh	r2, [r3, #14]
 483 009c FB68     		ldr	r3, [r7, #12]
 484 009e 9B8A     		ldrh	r3, [r3, #20]
 485 00a0 9A42     		cmp	r2, r3
 486 00a2 0ED1     		bne	.L16
 377:../Generated_Code/SPI.c ****         DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by Send
 487              		.loc 1 377 0
 488 00a4 FB68     		ldr	r3, [r7, #12]
 489 00a6 0022     		mov	r2, #0
 490 00a8 9A82     		strh	r2, [r3, #20]
 378:../Generated_Code/SPI.c ****         DeviceDataPrv->SerFlag |= BLOCK_SENT; /* Set data block sent flag */
 491              		.loc 1 378 0
 492 00aa FB68     		ldr	r3, [r7, #12]
 493 00ac 9B7D     		ldrb	r3, [r3, #22]
 494 00ae 0122     		mov	r2, #1
 495 00b0 1343     		orr	r3, r2
 496 00b2 DAB2     		uxtb	r2, r3
 497 00b4 FB68     		ldr	r3, [r7, #12]
 498 00b6 9A75     		strb	r2, [r3, #22]
 379:../Generated_Code/SPI.c ****         SPI_OnBlockSent(DeviceDataPrv->UserData);
 499              		.loc 1 379 0
 500 00b8 FB68     		ldr	r3, [r7, #12]
 501 00ba 9B69     		ldr	r3, [r3, #24]
 502 00bc 181C     		mov	r0, r3
 503 00be FFF7FEFF 		bl	SPI_OnBlockSent
 504              	.L16:
 380:../Generated_Code/SPI.c ****       }
 381:../Generated_Code/SPI.c ****     }
 382:../Generated_Code/SPI.c ****   }
 383:../Generated_Code/SPI.c **** }
 505              		.loc 1 383 0
 506 00c2 BD46     		mov	sp, r7
 507 00c4 04B0     		add	sp, sp, #16
 508              		@ sp needed for prologue
 509 00c6 80BD     		pop	{r7, pc}
 510              	.L20:
 511              		.align	2
 512              	.L19:
 513 00c8 00600740 		.word	1074225152
 514              		.cfi_endproc
 515              	.LFE4:
 517              		.text
 518              	.Letext0:
 519              		.file 2 "C:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 520              		.file 3 "C:/Users/SAE_LP1/workspace/InjBoard/Generated_Code/PE_Types.h"
 521              		.file 4 "C:/Freescale/CW MCU v10.7/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 SPI.c
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:24     .text.SPI_Init:00000000 $t
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:29     .text.SPI_Init:00000000 SPI_Init
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:161    .text.SPI_Init:000000bc $d
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:172    .text.SPI_ReceiveBlock:00000000 $t
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:177    .text.SPI_ReceiveBlock:00000000 SPI_ReceiveBlock
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:250    .text.SPI_ReceiveBlock:00000058 $d
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:255    .text.SPI_SendBlock:00000000 $t
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:260    .text.SPI_SendBlock:00000000 SPI_SendBlock
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:322    .text.SPI_GetBlockSentStatus:00000000 $t
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:327    .text.SPI_GetBlockSentStatus:00000000 SPI_GetBlockSentStatus
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:374    .text.SPI_Main:00000000 $t
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:379    .text.SPI_Main:00000000 SPI_Main
C:\Users\SAE_LP1\AppData\Local\Temp\ccoJTTuU.s:513    .text.SPI_Main:000000c8 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.aba60cd3b17efbc2d56a1d9fc6f583a6
                           .group:00000000 wm4.ewl_c_version.h.9.0bcb57d6a3f89baae1f9b121de2772f5
                           .group:00000000 wm4.os_enum.h.9.03d7426d632bb1a35ec1708754c41daf
                           .group:00000000 wm4.ansi_prefix.ARM.h.13.2dd306b0ccbe86124098bfe3a0b58d88
                           .group:00000000 wm4.ansi_parms.h.64.05090287ebda70c0d79c02b050dca090
                           .group:00000000 wm4.limits_api.h.9.bc6daa20b3abae2bba6c512044e73b43
                           .group:00000000 wm4.ewl_lib_ext1.h.14.f9b057cc049671136093886db2a3473f
                           .group:00000000 wm4.cstdint.137.268b37259d2d366c21376cbd280e10d7
                           .group:00000000 wm4.PE_Types.h.69.dc3ff080ea7da418697fe83347baa9b7
                           .group:00000000 wm4.PE_Error.h.60.6ccf96637e85421388d147a5dcbc3621
                           .group:00000000 wm4.PE_Const.h.61.443ca05468cb0c6bf080e06394e39146
                           .group:00000000 wm4.MKL25Z4.h.61.adbdc31ae5ef570825ab0667cccdf447
                           .group:00000000 wm4.size_t.h.9.f983491a73b5c81f421ee8223b1ac5c0
                           .group:00000000 wm4.ewl_rsize_t.h.11.b283831bb803e76ceb1756da2df9a1b5
                           .group:00000000 wm4.cstddef.32.067e2ea187472b6198f9ace951e27a51
                           .group:00000000 wm4.va_list.h.9.b0bb078841c0305c2667a31da10a9070
                           .group:00000000 wm4.file_struc.h.13.79700b909bfbc91e5b3cffa0100f62cf
                           .group:00000000 wm4.stdarg.ARM.h.9.32516e68edcca81ab31f48f233894821
                           .group:00000000 wm4.stdio_api.h.71.3b2f2f9a22fa2b89114b19a43e47537d
                           .group:00000000 wm4.cstdio.1186.6c7f5c80aaa542dbe41dde866b3043d9
                           .group:00000000 wm4.Cpu.h.78.e1dd9945a5e7ab9c31a38ba183a322df
                           .group:00000000 wm4.IO1.h.123.12a3ddb175f8510413e272cf486b6f13
                           .group:00000000 wm4.PDD_Types.h.5.e0b4125fe5201c5e1f688b067f4f0d54
                           .group:00000000 wm4.SPI_PDD.h.122.d5ee5c31bb578b79d5a94fe7d2fb776d
                           .group:00000000 wm4.SPI.h.133.ebf88e2f44f34088fd559df94ff085f7
                           .group:00000000 wm4.GPIO_PDD.h.9.194cb77f647f40e9013b4c76617a0f52
                           .group:00000000 wm4.PORT_PDD.h.9.e24435d4c3cbcc67beceb9e359966485
                           .group:00000000 wm4.SPIO.h.115.4aa61cdf57e3ce02c8471e878bd2249b
                           .group:00000000 wm4.TPM_PDD.h.9.31a1556de00afefbac847df3173403c0
                           .group:00000000 wm4.TU1.h.131.b88ff748c6c68c5a4fb5a26e2d236fa3
                           .group:00000000 wm4.PWM1.h.115.680dc27522312ce22703fe373ae9c8c9
                           .group:00000000 wm4.LEDRed.h.81.c201eeb213f541d934eae6e245311c3d
                           .group:00000000 wm4.LEDGreen.h.82.6bfe1b791f43b4324e0dea73e093527e
                           .group:00000000 wm4.GPIO1.h.102.0c6f30aac87db5bf3dfd0d28f5edf4cc

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SPI_OnBlockReceived
SPI_OnBlockSent
